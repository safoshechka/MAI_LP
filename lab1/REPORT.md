# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Сафонникова А.Р.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |


## Введение

Списки — важная структура в Прологе. Списки позволяют хранить произвольное количество данных. Связный список — структура данных, состоящая из узлов. Узел содержит данные и ссылку (указатель, связку) на один или два соседних узла. Списки языка Prolog являются односвязными, т.е. каждый узел содержит лишь одну ссылку. 

То, что называется списком в императивных языках, сильно отличается от списка в Прологе. Не во всех императивных языках есть такая структура данных, как список. Обрабатывать элементы списка в Прологе можно только рекурсивно, разделяя список на голову и хвост. В императивных языках, чтобы обратиться к какому-то элементу списка, мы можем использовать итераторы. Список в императивном языке может содержать в себе только элементы одинакового типа, в Прологе списки содержат любые элементы. Логичнее было бы сравнить списки в Прологе с массивами, т.к. и те, и другие чаще других типов используются в программах. Но к элементам массива мы имеем произвольный доступ, чего не скажешь о списках.

## Задание 1.1: Предикат обработки списка

`delete_(X1,X2)` - удаление первых трёх элементов списка

Примеры использования:
```prolog
?- delete_([1,2,3],X)
X = []
?- delete_([1,2,3,4,5,6,100], X).
X = [4, 5, 6, 100]

```

Реализация:

```prolog
% с использованием стандартных предикатов 
delete_(X, X_3):- length(X, R), R > 3, append([_], X_1, X), append([_], X_2, X_1), append([_], X_3, X_2),!.
delete_(X, []):- length(X, R), R =< 3. 

% без использования стандартных предикатов
remove_first([_|X], X).
delete_(X, X_3):- length(X, R), R > 3, remove_first(X, X_1),remove_first(X_1, X_2), remove_first(X_2, X_3).
delete_(X, []):- length(X, R), R =< 3.
```

Проверяем с помощью предиката length, вычисляющего длину, будет ли она принимать значение большее 3, если больше, удаляем три раза первый элемент(либо с помощью функции `remove_first`, либо с помощью функции `append`), если меньше, возвращаем пустой список.

## Задание 1.2: Предикат обработки числового списка

`arithmetic_mean(X1,X2)` - вычичсление среденего арифметического элементов списка

Примеры использования:
```prolog
?- arithmetic_mean([1,2,3,4,5],X).
X = 3
?- arithmetic_mean_([100,0],X).
X = 50
```

Реализация:

```prolog
% с использованием стандартных предикатов 
sum([],0).
sum([X|T],S) :- sum(T,S1), S is S1+X.
arithmetic_mean(T,X) :- length(T,L), arithmetic_mean(T,X,L).
arithmetic_mean(T,X,L) :- sum(T,S), X is S/L. 

% без использования стандартных предикатов
arithmetic_mean_([],0,0).
arithmetic_mean_(T,X) :- arithmetic_mean_(T,S,C), X is S/C,!.
arithmetic_mean_([X|T],S,C) :- arithmetic_mean_(T,S1,C1), S is S1+X, C is C1+1.
```

В реализации с использованием стандартных предикатов используются два вспомогатльных предиката - предикат нахождения суммы всех элементов `sum` и предикат `length`, определяющий длину списка. Сумма элементов делится на длину списка. 
В реализации без использования стандартных предикатов длина и сумма элементов считаются в процессе выполнения программы - во время каждой процедуры отделения головы от хвоста к одной из переменных (S) прибавляется значение головы, а в другой (C) - единица.

## Задание 2: Реляционное представление данных

Реляционное представление данных, как правило, достаточно удобно для понимания. Это не единственное достоинство такого представления данных - например, преимуществом такого представления, по сравнению с другими, является тот факт, что для организации запросов нет необходимости знать организацию конкретной базы данных во внешней памяти, а также строгие правила проектирования, базирующиеся на математическом аппарате, и полная независимость данных. Изменения в прикладной программе при изменении реляционной БД минимальны.

Однако, БД занимает достаточно большой объем внешней памяти, а также скорость доступа к данным не самая высокая. Также при довольно большом и разном объеме данных появляется множество "таблиц", что приводит к меньшей читабельности БД, да и не всегда данные можно представить данные в виде таблиц.

В конкретном файле three.pl данные представлены в виде фактов, в которых хранятся данные о группе студента, фамилии и его оценках за разные предметы (в виде списка). Это довольно удобный способ представления данных - при поиске той или иной информации не придется перебирать слишком большое количество фактов, однако во время каждой итерации приходится сохранять большое количество данных, которые могут быть не нужны. Если сравнивать с другими предоставленными файлами, которые в своей лабораторной работе я не использовала, третий файл является "золотой серединой" между большим количеством различных фактов (что может быть слишком затратным по времени) и огромным количеством данных а каждом факте (что очень затратно по памяти).



`exms(X)` - предикат истинен, если студент сдал все экзамены(нет ни одной 'двойки'), и ложен, если студент не сдал хотя бы один экзамен. Рекурсивно просматривается список оценок студента по всем предметам. Если за экзамен оценка 2, то предикат ложен, иначе истинен. 

Реализация:

```prolog
exms(Stud):-
	student(_,Stud,Marks),
	not(member(grade(_,2),Marks)).
```

`sredn(X,Y)`- `X` - фамилия студента, `Y` - средняя оценка студента по всем предметам.
Рекурсивно просматриваются оценки студента по всем предметам, они суммируются, а потом полученное число делится на количество предметов. 

Реализация:

```prolog
sredn(Stud,Mark):-
	student(_,Stud,Q),
	sum(Q, Sum),
	length(Q,Len),
	Mark is Sum / Len.
  
% сумма всех элементов в списке
% (список, сумма)
sum([grade(_, H)|T],N):-
	sum(T,K),
	N is K+H.
  sum([],0).
```

`sfailed(X, Y)` - `Y` - количество студентов, не сдавших предмет `X`(получивших оценку 2). Создается список, содержащий списки из оценок всех студентов по всем предметам. Рекурсивно проверяется, содержится ли в голове списка предмет, по которому получена оценка 2 - если содержится, то `Y` увеличивается на 1, если нет, то просматривается хвост "общего" списка. 

Реализация:

```prolog
sfailed(Subj,N):-
	subject(Ss,Subj),
	findall(A,(student(_,_,A),gradeInList(A,Ss)),AllMarks),
	length(AllMarks,N).

gradeInList([grade(Subj,2)|_],Subj).
gradeInList([_|Tail],Subj):-
	gradeInList(Tail,Subj).
```

`thebest(X, Y)` - в группе `X` ищутся студенты, имеющие максимальный средний балл в ней. `Y` - список фамилий этих студентов. Ищется максимальный средний балл в данной группе, после чего ищутся студенты этой группы, имеющие такой средний балл.

Реализация:

```prolog
thebest(Group,N):-
 % список со всеми средними оценками
 findall(Mark, (student(Group,Stud,_), sredn(Stud,Mark)),Marks),
 % максимальная оценка
 max(Marks,Max),
 % список студентов с максимальной оценкой
 findall(A,(student(Group,A,_), sredn(A,M), M==Max), N),!.
  
% нахождение максимального из положительного числового списка
% (список, максимум)
max([],0).
max([H|T],N):-
  max(T,R),
  H =< R,
  N is R.
max([H|T],N):-
  max(T,R),
  H >= R,
  N is H.
```

Примеры использования:

```prolog
?- sredn('Петров',X).
X = 4. % средняя оценка Петрова по всем предметам

?- sredn('Эфиркина',X).
X = 3.8333333333333335. % средняя оценка Эфиркиной по всем предметам

?- exms('Шарпин').
false. % Шарпин что-то не сдал

?- exms('Фулл').
true. % Фулл сдал все экзамены

?- sfailed('Логическое программирование',X).
X = 0. % Логическое программирование сдали все студенты

?- sfailed('Информатика',X).
X = 3. % Информатику не сдало 3 студента

?- thebest(103,X).
X = ['Вебсервисов'].  % Вебсервисов лучший в группе 103

?- thebest(102,X).
X = ['Азурин']. % Азурин лучший в группе 102
```



## Выводы

В императивных языках мы указываем как что-либо сделать, в Прологе - что необходимо сделать. Мы сообщаем системе, что нам известно и задаем вопросы. Программы на Прологе выглядят простыми, но за ними скрывается мощный логический бэкграунд. Неудивительно, что такое программирование называется логическим, ведь оно помогает найти нетривиальное решение какой-то обыденной задачи. Начинаешь думать о программе как о наборе целей, тем самым разбивая большую задачу на множество простых. Думаю, чтобы понять концепции логического программирования нужно больше практики. Когда сталкиваешься с каким-то принципиально новым для себя явлением, сложно сразу осмыслить его фундаментальные начала. Мне кажется, легче сначала узнать на интуитивном уровне, как это работает, а потом приложить свой опыт к более глубокому изучению. Но для меня не совсем понятно, для чего нужно решать подобные задачи через Пролог, когда можно облегчить жизнь и использовать императивные языки программирования.




